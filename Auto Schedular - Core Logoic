// services/autoScheduler.js - Auto-Scheduling Service
const NotificationService = require('./notifications');

class AutoScheduler {
  constructor(database) {
    this.db = database;
    this.notificationService = new NotificationService();
    
    // Configuration constants
    this.MIN_PLAYERS_PER_GAME = 10;
    this.MAX_PLAYERS_PER_GAME = 22;
    this.OPTIMAL_PLAYERS_PER_GAME = 18;
    this.MAX_SKILL_DIFFERENCE = 2.0;
    this.LOOKAHEAD_DAYS = 3; // How many days ahead to schedule
  }

  /**
   * Main daily scheduling method - called by cron job
   */
  async runDailyScheduling() {
    console.log('ü§ñ Starting daily auto-scheduling...');
    
    const results = [];
    const today = new Date();
    
    // Schedule for next few days
    for (let i = 1; i <= this.LOOKAHEAD_DAYS; i++) {
      const targetDate = new Date(today);
      targetDate.setDate(today.getDate() + i);
      const dateStr = targetDate.toISOString().split('T')[0];
      
      try {
        const dayResult = await this.scheduleDayBookings(dateStr);
        results.push({ date: dateStr, ...dayResult });
        
        // Small delay between dates
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        console.error(`Failed to schedule ${dateStr}:`, error);
        results.push({ date: dateStr, error: error.message });
      }
    }
    
    console.log('‚úÖ Daily auto-scheduling completed');
    return results;
  }

  /**
   * Schedule bookings for a specific date
   */
  async scheduleDayBookings(targetDate, forceReschedule = false) {
    console.log(`üìÖ Scheduling bookings for ${targetDate}`);
    
    try {
      // Check if already scheduled (unless forced)
      if (!forceReschedule) {
        const existingBookings = await this.db.query(`
          SELECT COUNT(*) as count FROM bookings 
          WHERE booking_date = $1 AND booking_type = 'auto'
        `, [targetDate]);
        
        if (parseInt(existingBookings.rows[0].count) > 0) {
          console.log(`‚è≠Ô∏è Date ${targetDate} already has auto-scheduled bookings`);
          return { status: 'skipped', reason: 'already_scheduled' };
        }
      }

      // Get available time slots for the date
      const availableSlots = await this.getAvailableTimeSlots(targetDate);
      
      if (availableSlots.length === 0) {
        console.log(`‚ùå No available slots for ${targetDate}`);
        return { status: 'failed', reason: 'no_available_slots' };
      }

      // Get available players for the date
      const availablePlayers = await this.getAvailablePlayers(targetDate);
      
      if (availablePlayers.length < this.MIN_PLAYERS_PER_GAME) {
        console.log(`‚ùå Insufficient players (${availablePlayers.length}) for ${targetDate}`);
        return { status: 'failed', reason: 'insufficient_players', playerCount: availablePlayers.length };
      }

      // Apply admin overrides (user exclusions, forced inclusions)
      const filteredPlayers = await this.applyAdminOverrides(availablePlayers, targetDate);
      
      // Schedule optimal number of games
      const scheduledBookings = await this.scheduleOptimalGames(
        filteredPlayers, 
        availableSlots, 
        targetDate
      );

      console.log(`‚úÖ Scheduled ${scheduledBookings.length} games for ${targetDate}`);
      
      return {
        status: 'success',
        gamesScheduled: scheduledBookings.length,
        playersAssigned: scheduledBookings.reduce((sum, booking) => sum + booking.playerCount, 0),
        bookings: scheduledBookings
      };
      
    } catch (error) {
      console.error(`Failed to schedule ${targetDate}:`, error);
      throw error;
    }
  }

  /**
   * Get available time slots for a date
   */
  async getAvailableTimeSlots(date) {
    const result = await this.db.query(`
      SELECT 
        ta.turf_id,
        ta.start_time,
        ta.end_time,
        ta.price_override,
        t.name as turf_name,
        t.hourly_rate,
        t.capacity
      FROM turf_availability ta
      JOIN turfs t ON ta.turf_id = t.id
      WHERE ta.date = $1 
        AND ta.is_available = true
        AND t.is_active = true
        AND NOT EXISTS (
          SELECT 1 FROM bookings b 
          WHERE b.turf_id = ta.turf_id 
            AND b.booking_date = ta.date
            AND b.start_time = ta.start_time
            AND b.status != 'cancelled'
        )
      ORDER BY ta.start_time, t.hourly_rate
    `, [date]);

    return result.rows;
  }

  /**
   * Get available players for a date
   */
  async getAvailablePlayers(date) {
    const dayOfWeek = new Date(date).toLocaleLowerString('en-us', { weekday: 'long' });
    
    const result = await this.db.query(`
      SELECT DISTINCT
        u.id,
        u.full_name,
        u.skill_level,
        u.position,
        u.total_games_played,
        up.preferred_time_slots,
        up.preferred_days,
        up.max_games_per_week,
        COALESCE(recent_games.games_this_week, 0) as games_this_week
      FROM users u
      LEFT JOIN user_preferences up ON u.id = up.user_id
      LEFT JOIN (
        SELECT 
          ta.user_id,
          COUNT(*) as games_this_week
        FROM team_assignments ta
        JOIN bookings b ON ta.booking_id = b.id
        WHERE b.booking_date >= $1 - INTERVAL '7 days'
          AND b.booking_date < $1
          AND b.status = 'scheduled'
        GROUP BY ta.user_id
      ) recent_games ON u.id = recent_games.user_id
      WHERE u.is_active = true
        AND u.is_admin = false
        AND (up.preferred_days IS NULL OR $2 = ANY(up.preferred_days))
        AND (up.max_games_per_week IS NULL OR COALESCE(recent_games.games_this_week, 0) < up.max_games_per_week)
        AND NOT EXISTS (
          SELECT 1 FROM team_assignments ta2
          JOIN bookings b2 ON ta2.booking_id = b2.id
          WHERE ta2.user_id = u.id 
            AND b2.booking_date = $1 
            AND b2.status = 'scheduled'
        )
      ORDER BY 
        COALESCE(recent_games.games_this_week, 0) ASC,
        u.last_active_date DESC,
        RANDOM()
    `, [date, dayOfWeek]);

    return result.rows;
  }

  /**
   * Apply admin overrides for player selection
   */
  async applyAdminOverrides(players, date) {
    // Get active overrides
    const overrides = await this.db.query(`
      SELECT override_type, target_id, override_data
      FROM admin_overrides
      WHERE is_active = true
        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
        AND override_type IN ('user_exclusion', 'user_force_include')
    `);

    let filteredPlayers = [...players];

    for (const override of overrides.rows) {
      if (override.override_type === 'user_exclusion') {
        filteredPlayers = filteredPlayers.filter(p => p.id !== override.target_id);
        console.log(`üö´ Excluded user ${override.target_id} due to admin override`);
        
      } else if (override.override_type === 'user_force_include') {
        // Check if user is not already in the list
        const exists = filteredPlayers.find(p => p.id === override.target_id);
        if (!exists) {
          // Fetch user details and add to list
          const userResult = await this.db.query(`
            SELECT id, full_name, skill_level, position, total_games_played
            FROM users WHERE id = $1 AND is_active = true
          `, [override.target_id]);
          
          if (userResult.rows.length > 0) {
            filteredPlayers.push({
              ...userResult.rows[0],
              games_this_week: 0,
              forced_include: true
            });
            console.log(`‚≠ê Force included user ${override.target_id} due to admin override`);
          }
        }
      }
    }

    return filteredPlayers;
  }

  /**
   * Schedule optimal games for the day
   */
  async scheduleOptimalGames(players, timeSlots, date) {
    const scheduledBookings = [];
    let availablePlayers = [...players];

    // Sort time slots by preference (earlier slots preferred)
    timeSlots.sort((a, b) => a.start_time.localeCompare(b.start_time));

    for (const slot of timeSlots) {
      if (availablePlayers.length < this.MIN_PLAYERS_PER_GAME) {
        console.log(`‚èπÔ∏è Not enough players remaining (${availablePlayers.length}) for another game`);
        break;
      }

      // Filter players available for this time slot
      const slotAvailablePlayers = this.filterPlayersByTimePreference(
        availablePlayers, 
        slot.start_time, 
        slot.end_time
      );

      if (slotAvailablePlayers.length < this.MIN_PLAYERS_PER_GAME) {
        console.log(`‚è≠Ô∏è Skipping slot ${slot.start_time}-${slot.end_time}: only ${slotAvailablePlayers.length} available players`);
        continue;
      }

      // Select optimal number of players for this game
      const gamePlayerCount = Math.min(
        this.OPTIMAL_PLAYERS_PER_GAME,
        slot.capacity,
        slotAvailablePlayers.length
      );

      const selectedPlayers = this.selectBalancedPlayers(slotAvailablePlayers, gamePlayerCount);

      if (selectedPlayers.length < this.MIN_PLAYERS_PER_GAME) {
        console.log(`‚è≠Ô∏è Could not select enough balanced players for slot ${slot.start_time}`);
        continue;
      }

      // Create booking
      const booking = await this.createBooking(slot, date, selectedPlayers);
      
      if (booking) {
        scheduledBookings.push({
          ...booking,
          playerCount: selectedPlayers.length
        });

        // Remove selected players from available pool
        const selectedPlayerIds = selectedPlayers.map(p => p.id);
        availablePlayers = availablePlayers.filter(p => !selectedPlayerIds.includes(p.id));

        console.log(`‚úÖ Created booking for ${slot.start_time}-${slot.end_time} with ${selectedPlayers.length} players`);
      }
    }

    return scheduledBookings;
  }

  /**
   * Filter players by time slot preference
   */
  filterPlayersByTimePreference(players, startTime, endTime) {
    return players.filter(player => {
      // If no preferences set, assume available for all times
      if (!player.preferred_time_slots || player.preferred_time_slots.length === 0) {
        return true;
      }

      // Check if this time slot matches any of the player's preferences
      return player.preferred_time_slots.some(prefSlot => {
        const [prefStart, prefEnd] = prefSlot.split('-');
        return startTime >= prefStart && endTime <= prefEnd;
      });
    });
  }

  /**
   * Select balanced players for a game
   */
  selectBalancedPlayers(players, targetCount) {
    // Sort players by priority (games played, skill balance, etc.)
    const sortedPlayers = [...players].sort((a, b) => {
      // Priority 1: Players with fewer games this week
      if (a.games_this_week !== b.games_this_week) {
        return a.games_this_week - b.games_this_week;
      }
      
      // Priority 2: Players who haven't played recently
      if (a.total_games_played !== b.total_games_played) {
        return a.total_games_played - b.total_games_played;
      }
      
      // Priority 3: Random selection for fairness
      return Math.random() - 0.5;
    });

    // Select players ensuring skill balance
    const selectedPlayers = [];
    let currentAvgSkill = 0;

    for (const player of sortedPlayers) {
      if (selectedPlayers.length >= targetCount) break;

      // Calculate projected average skill with this player
      const projectedAvg = (currentAvgSkill * selectedPlayers.length + player.skill_level) / (selectedPlayers.length + 1);

      // Add player if it doesn't create too much skill imbalance
      if (selectedPlayers.length === 0 || Math.abs(projectedAvg - 5.5) <= this.MAX_SKILL_DIFFERENCE) {
        selectedPlayers.push(player);
        currentAvgSkill = projectedAvg;
      }
    }

    // If we couldn't get enough players with skill balance, just take the top players
    if (selectedPlayers.length < this.MIN_PLAYERS_PER_GAME) {
      return sortedPlayers.slice(0, Math.min(targetCount, sortedPlayers.length));
    }

    return selectedPlayers;
  }

  /**
   * Create a booking in the database
   */
  async createBooking(slot, date, selectedPlayers) {
    const client = await this.db.connect();
    
    try {
      await client.query('BEGIN');

      // Calculate cost
      const hourlyRate = slot.price_override || slot.hourly_rate;
      const duration = this.calculateDuration(slot.start_time, slot.end_time);
      const totalCost = hourlyRate * duration;

      // Create booking
      const bookingResult = await client.query(`
        INSERT INTO bookings (turf_id, booking_date, start_time, end_time, total_cost, booking_type, attendance_count)
        VALUES ($1, $2, $3, $4, $5, 'auto', $6)
        RETURNING *
      `, [slot.turf_id, date, slot.start_time, slot.end_time, totalCost, selectedPlayers.length]);

      const booking = bookingResult.rows[0];

      // Assign players to teams
      await this.assignPlayersToTeams(client, booking.id, selectedPlayers);

      // Send notifications
      await this.sendBookingNotifications(booking, selectedPlayers);

      await client.query('COMMIT');
      
      return booking;

    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error creating booking:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Assign players to balanced teams
   */
  async assignPlayersToTeams(client, bookingId, players) {
    // Get available teams
    const teamsResult = await client.query('SELECT id FROM teams ORDER BY name');
    const teams = teamsResult.rows;

    if (teams.length < 2) {
      throw new Error('Not enough teams available for assignment');
    }

    // Sort players by skill level for balanced distribution
    const sortedPlayers = [...players].sort((a, b) => b.skill_level - a.skill_level);

    // Assign players alternately to teams for balance
    const assignments = [];
    
    for (let i = 0; i < sortedPlayers.length; i++) {
      const player = sortedPlayers[i];
      const teamIndex = i % teams.length;
      const team = teams[teamIndex];

      assignments.push({
        booking_id: bookingId,
        user_id: player.id,
        team_id: team.id,
        assignment_type: 'auto'
      });
    }

    // Bulk insert assignments
    const values = assignments.map((_, index) => 
      `($${index * 4 + 1}, $${index * 4 + 2}, $${index * 4 + 3}, $${index * 4 + 4})`
    ).join(',');

    const params = assignments.flatMap(a => [a.booking_id, a.user_id, a.team_id, a.assignment_type]);

    await client.query(`
      INSERT INTO team_assignments (booking_id, user_id, team_id, assignment_type)
      VALUES ${values}
    `, params);

    console.log(`üë• Assigned ${players.length} players to ${teams.length} teams`);
  }

  /**
   * Send notifications to assigned players
   */
  async sendBookingNotifications(booking, players) {
    const notifications = players.map(player => ({
      user_id: player.id,
      type: 'booking_scheduled',
      title: 'New Game Scheduled!',
      message: `You've been scheduled for a game on ${booking.booking_date} at ${booking.start_time}`,
      data: {
        booking_id: booking.id,
        booking_date: booking.booking_date,
        start_time: booking.start_time,
        end_time: booking.end_time
      }
    }));

    await this.notificationService.createBulkNotifications(notifications);
    console.log(`üì± Sent notifications to ${players.length} players`);
  }

  /**
   * Weekly team rebalancing to ensure fairness
   */
  async runWeeklyTeamRebalancing() {
    console.log('‚öñÔ∏è Starting weekly team rebalancing...');
    
    try {
      // Get team statistics from last 4 weeks
      const teamStats = await this.db.query(`
        SELECT 
          t.id,
          t.name,
          COUNT(ta.id) as total_assignments,
          AVG(u.skill_level) as avg_skill_level,
          AVG(CASE WHEN ta.performance_rating IS NOT NULL THEN ta.performance_rating ELSE u.skill_level END) as avg_performance
        FROM teams t
        LEFT JOIN team_assignments ta ON t.id = ta.team_id
        LEFT JOIN bookings b ON ta.booking_id = b.id
        LEFT JOIN users u ON ta.user_id = u.id
        WHERE b.booking_date >= CURRENT_DATE - INTERVAL '28 days'
          AND b.status IN ('scheduled', 'completed')
        GROUP BY t.id, t.name
        ORDER BY t.name
      `);

      // Calculate balance metrics
      const stats = teamStats.rows;
      if (stats.length < 2) {
        console.log('‚ö†Ô∏è Not enough teams for rebalancing');
        return { status: 'skipped', reason: 'insufficient_teams' };
      }

      const avgSkills = stats.map(s => parseFloat(s.avg_skill_level || 0));
      const skillVariance = this.calculateVariance(avgSkills);
      
      console.log('üìä Team balance metrics:', {
        teams: stats.length,
        skillVariance: skillVariance.toFixed(3),
        averageSkills: avgSkills
      });

      // If variance is too high, trigger rebalancing for future games
      if (skillVariance > 1.0) {
        await this.rebalanceUpcomingGames();
        console.log('‚úÖ Team rebalancing completed - high variance detected');
        return { status: 'rebalanced', skillVariance };
      } else {
        console.log('‚úÖ Teams are well balanced - no action needed');
        return { status: 'balanced', skillVariance };
      }

    } catch (error) {
      console.error('Weekly rebalancing failed:', error);
      throw error;
    }
  }

  /**
   * Rebalance upcoming games for better team equity
   */
  async rebalanceUpcomingGames() {
    // Get upcoming auto-scheduled games (next 7 days)
    const upcomingGames = await this.db.query(`
      SELECT DISTINCT b.id, b.booking_date, b.start_time
      FROM bookings b
      WHERE b.booking_date BETWEEN CURRENT_DATE + INTERVAL '1 day' AND CURRENT_DATE + INTERVAL '7 days'
        AND b.status = 'scheduled'
        AND b.booking_type = 'auto'
      ORDER BY b.booking_date, b.start_time
      LIMIT 5
    `);

    let rebalancedCount = 0;
    
    for (const game of upcomingGames.rows) {
      try {
        // Get current team assignments
        const assignments = await this.db.query(`
          SELECT ta.*, u.skill_level, u.position
          FROM team_assignments ta
          JOIN users u ON ta.user_id = u.id
          WHERE ta.booking_id = $1
        `, [game.id]);

        if (assignments.rows.length < this.MIN_PLAYERS_PER_GAME) continue;

        // Reassign players for better balance
        const players = assignments.rows.map(a => ({
          id: a.user_id,
          skill_level: a.skill_level,
          position: a.position
        }));

        // Delete existing assignments
        await this.db.query('DELETE FROM team_assignments WHERE booking_id = $1', [game.id]);

        // Create new balanced assignments
        const client = await this.db.connect();
        try {
          await this.assignPlayersToTeams(client, game.id, players);
          rebalancedCount++;
          console.log(`‚öñÔ∏è Rebalanced game ${game.booking_date} ${game.start_time}`);
        } finally {
          client.release();
        }

      } catch (error) {
        console.error(`Failed to rebalance game ${game.id}:`, error);
      }
    }

    console.log(`‚úÖ Rebalanced ${rebalancedCount} upcoming games`);
  }

  /**
   * Handle player availability changes
   */
  async handlePlayerAvailabilityChange(userId, newPreferences) {
    console.log(`üîÑ Processing availability change for user ${userId}`);
    
    try {
      // Update user preferences
      await this.db.query(`
        UPDATE user_preferences 
        SET 
          preferred_time_slots = $1,
          preferred_days = $2,
          max_games_per_week = $3,
          updated_at = CURRENT_TIMESTAMP
        WHERE user_id = $4
      `, [
        newPreferences.preferred_time_slots,
        newPreferences.preferred_days,
        newPreferences.max_games_per_week,
        userId
      ]);

      // Check if this affects upcoming bookings
      const upcomingConflicts = await this.db.query(`
        SELECT b.id, b.booking_date, b.start_time, b.end_time
        FROM bookings b
        JOIN team_assignments ta ON b.id = ta.booking_id
        WHERE ta.user_id = $1
          AND b.booking_date > CURRENT_DATE
          AND b.status = 'scheduled'
          AND b.booking_type = 'auto'
      `, [userId]);

      const conflicts = [];
      
      for (const booking of upcomingConflicts.rows) {
        const isAvailable = this.checkPlayerAvailability(
          newPreferences,
          booking.booking_date,
          booking.start_time,
          booking.end_time
        );

        if (!isAvailable) {
          conflicts.push(booking);
          
          // Remove player from conflicting bookings
          await this.db.query(`
            DELETE FROM team_assignments 
            WHERE booking_id = $1 AND user_id = $2
          `, [booking.id, userId]);

          // Try to find replacement player
          await this.findReplacementPlayer(booking.id, booking.booking_date);
        }
      }

      if (conflicts.length > 0) {
        // Notify user about removed bookings
        await this.notificationService.createNotification({
          user_id: userId,
          type: 'availability_conflict',
          title: 'Schedule Updated',
          message: `You've been removed from ${conflicts.length} upcoming game(s) due to availability changes.`,
          data: { conflicts: conflicts.map(c => c.id) }
        });
      }

      return {
        status: 'updated',
        conflictsResolved: conflicts.length
      };

    } catch (error) {
      console.error('Error handling availability change:', error);
      throw error;
    }
  }

  /**
   * Find replacement player for a booking
   */
  async findReplacementPlayer(bookingId, bookingDate) {
    const booking = await this.db.query(`
      SELECT b.*, t.capacity
      FROM bookings b
      JOIN turfs t ON b.turf_id = t.id
      WHERE b.id = $1
    `, [bookingId]);

    if (booking.rows.length === 0) return false;

    const gameInfo = booking.rows[0];

    // Get available replacement players
    const availablePlayers = await this.getAvailablePlayers(bookingDate);
    
    // Filter out players already assigned to this game
    const assignedPlayerIds = await this.db.query(`
      SELECT user_id FROM team_assignments WHERE booking_id = $1
    `, [bookingId]);
    
    const assignedIds = assignedPlayerIds.rows.map(r => r.user_id);
    const replacementCandidates = availablePlayers.filter(p => !assignedIds.includes(p.id));

    if (replacementCandidates.length === 0) {
      console.log(`‚ùå No replacement players available for booking ${bookingId}`);
      return false;
    }

    // Select best replacement (balanced skill, fewer games played)
    const currentAssignments = await this.db.query(`
      SELECT AVG(u.skill_level) as avg_skill
      FROM team_assignments ta
      JOIN users u ON ta.user_id = u.id
      WHERE ta.booking_id = $1
    `, [bookingId]);

    const targetSkill = parseFloat(currentAssignments.rows[0].avg_skill || 5.5);
    
    const bestReplacement = replacementCandidates
      .sort((a, b) => {
        const skillDiffA = Math.abs(a.skill_level - targetSkill);
        const skillDiffB = Math.abs(b.skill_level - targetSkill);
        
        if (skillDiffA !== skillDiffB) return skillDiffA - skillDiffB;
        return a.games_this_week - b.games_this_week;
      })[0];

    // Assign replacement to a team (choose team with fewer players)
    const teamCounts = await this.db.query(`
      SELECT team_id, COUNT(*) as player_count
      FROM team_assignments
      WHERE booking_id = $1
      GROUP BY team_id
      ORDER BY player_count ASC
    `, [bookingId]);

    const targetTeam = teamCounts.rows[0]?.team_id;

    if (targetTeam) {
      await this.db.query(`
        INSERT INTO team_assignments (booking_id, user_id, team_id, assignment_type)
        VALUES ($1, $2, $3, 'auto')
      `, [bookingId, bestReplacement.id, targetTeam]);

      // Notify new player
      await this.notificationService.createNotification({
        user_id: bestReplacement.id,
        type: 'replacement_assignment',
        title: 'Added to Game!',
        message: `You've been added to a game on ${bookingDate} as a replacement player.`,
        data: { booking_id: bookingId }
      });

      console.log(`‚úÖ Found replacement player ${bestReplacement.id} for booking ${bookingId}`);
      return true;
    }

    return false;
  }

  /**
   * Utility functions
   */
  
  calculateDuration(startTime, endTime) {
    const start = new Date(`2000-01-01T${startTime}`);
    const end = new Date(`2000-01-01T${endTime}`);
    return (end - start) / (1000 * 60 * 60); // hours
  }

  calculateVariance(numbers) {
    const avg = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    const squaredDiffs = numbers.map(num => Math.pow(num - avg, 2));
    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;
  }

  checkPlayerAvailability(preferences, date, startTime, endTime) {
    if (!preferences.preferred_days || !preferences.preferred_time_slots) {
      return true; // No restrictions
    }

    const dayOfWeek = new Date(date).toLocaleDateString('en-us', { weekday: 'long' }).toLowerCase();
    
    // Check day preference
    if (!preferences.preferred_days.includes(dayOfWeek)) {
      return false;
    }

    // Check time preference
    return preferences.preferred_time_slots.some(slot => {
      const [slotStart, slotEnd] = slot.split('-');
      return startTime >= slotStart && endTime <= slotEnd;
    });
  }

  /**
   * Get scheduling statistics for admin dashboard
   */
  async getSchedulingStats(days = 30) {
    const stats = await this.db.query(`
      SELECT 
        COUNT(*) as total_bookings,
        COUNT(CASE WHEN booking_type = 'auto' THEN 1 END) as auto_bookings,
        COUNT(CASE WHEN booking_type = 'manual' THEN 1 END) as manual_bookings,
        AVG(attendance_count) as avg_attendance,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_games,
        COUNT(CASE WHEN status = 'cancelled' THEN 1 END) as cancelled_games,
        AVG(game_quality_rating) as avg_game_quality
      FROM bookings
      WHERE booking_date >= CURRENT_DATE - INTERVAL '${days} days'
    `);

    const playerStats = await this.db.query(`
      SELECT 
        COUNT(DISTINCT ta.user_id) as active_players,
        AVG(player_games.game_count) as avg_games_per_player
      FROM team_assignments ta
      JOIN bookings b ON ta.booking_id = b.id
      JOIN (
        SELECT 
          ta2.user_id,
          COUNT(*) as game_count
        FROM team_assignments ta2
        JOIN bookings b2 ON ta2.booking_id = b2.id
        WHERE b2.booking_date >= CURRENT_DATE - INTERVAL '${days} days'
        GROUP BY ta2.user_id
      ) player_games ON ta.user_id = player_games.user_id
      WHERE b.booking_date >= CURRENT_DATE - INTERVAL '${days} days'
    `);

    return {
      period_days: days,
      booking_stats: stats.rows[0],
      player_stats: playerStats.rows[0]
    };
  }
}

module.exports = AutoScheduler;
